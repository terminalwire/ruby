# frozen_string_literal: true

require 'spec_helper'
require 'tempfile'

RSpec.describe 'Example Integration Usage' do
  # This example shows how to use the integration testing framework
  # to test real client-server interactions

  let(:test_adapter) { Terminalwire::Adapter::Test.new }
  let(:client_handler) do
    endpoint = double('endpoint', authority: 'example.com', to_url: 'ws://example.com')
    
    Terminalwire::Client::Handler.new(
      test_adapter,
      arguments: [],
      program_name: 'example_app',
      endpoint: endpoint
    ) do |handler|
      # Set up permissive entitlements for the example
      policy = Terminalwire::Client::Entitlement::Policy.resolve(authority: 'example.com')
      
      # Allow file operations
      paths = Terminalwire::Client::Entitlement::Paths.new
      paths.permit("**/*")
      policy.instance_variable_set(:@paths, paths)
      
      # Allow environment variable access
      env_vars = Terminalwire::Client::Entitlement::EnvironmentVariables.new
      env_vars.permit("EXAMPLE_TEST_VAR")
      env_vars.permit("TERMINALWIRE_HOME")
      policy.instance_variable_set(:@environment_variables, env_vars)
      
      handler.entitlement = policy
    end
  end

  describe 'complete workflow example' do
    it 'demonstrates a full client-server interaction' do
      # 1. Verify initialization message format
      initialization_message = {
        event: "initialization",
        protocol: { version: Terminalwire::VERSION },
        entitlement: client_handler.entitlement.serialize,
        program: { name: 'example_app', arguments: [] }
      }
      
      expect(initialization_message).to include(
        program: include(name: 'example_app')
      )

      # 2. Server sends a greeting to stdout
      stdout_command = {
        event: "resource",
        action: "command",
        name: "stdout",
        command: "print_line",
        parameters: { data: "Welcome to the example app!" }
      }
      
      # Client handles the command
      client_handler.handle(stdout_command)
      
      # Check success response
      response = test_adapter.response
      expect(response[:status]).to eq("success")

      # 3. Server creates a temporary file
      temp_content = "This is example content generated by the server"
      temp_path = "/tmp/example_file.txt"
      
      file_command = {
        event: "resource",
        action: "command",
        name: "file",
        command: "write",
        parameters: {
          path: temp_path,
          content: temp_content
        }
      }
      
      # Client executes file write
      client_handler.handle(file_command)
      
      # Verify file was created (in real usage)
      write_response = test_adapter.response
      expect(write_response[:status]).to eq("success")

      # 4. Server reads the file back
      read_command = {
        event: "resource",
        action: "command",
        name: "file",
        command: "read",
        parameters: { path: temp_path }
      }
      
      # Client reads the file
      client_handler.handle(read_command)
      
      read_response = test_adapter.response
      expect(read_response).to include(
        status: "success",
        response: temp_content
      )

      # 5. Server prints the file contents
      print_command = {
        event: "resource",
        action: "command",
        name: "stdout",
        command: "print_line",
        parameters: { data: "File contents: #{read_response[:response]}" }
      }
      
      client_handler.handle(print_command)
      
      success_response = test_adapter.response
      expect(success_response[:status]).to eq("success")

      # 6. Server exits cleanly
      exit_command = {
        event: "exit",
        status: 0
      }
      
      # Client handles exit (would normally terminate)
      expect {
        client_handler.handle(exit_command)
      }.to raise_error(SystemExit) do |error|
        expect(error.status).to eq(0)
      end
    end
  end

  describe 'error handling examples' do
    it 'handles permission denied scenarios' do
      # Try to read a file that doesn't exist
      command = {
        event: "resource",
        action: "command",
        name: "file",
        command: "read",
        parameters: { path: "/nonexistent/file.txt" }
      }
      
      # Client should handle the command but it will fail with an exception
      expect { client_handler.handle(command) }.to raise_error(Errno::ENOENT)
      
      # The error response should still be sent before the exception
      response = test_adapter.response
      if response
        expect(response[:status]).to eq("failure")
        expect(response[:response]).to include("No such file")
      end
    end

    it 'handles environment variable operations' do
      # Set a test environment variable
      ENV['EXAMPLE_TEST_VAR'] = 'test_value'
      
      begin
        # Try with a variable that we permit explicitly
        command = {
          event: "resource",
          action: "command",
          name: "environment_variable",
          command: "read",
          parameters: { name: "EXAMPLE_TEST_VAR" }
        }
        
        client_handler.handle(command)
        
        response = test_adapter.response
        expect(response).to include(
          status: "success",
          response: "test_value"
        )
      ensure
        ENV.delete('EXAMPLE_TEST_VAR')
      end
    end
  end

  describe 'batch operations example' do
    it 'performs multiple operations in sequence' do
      commands = [
        {
          event: "resource",
          action: "command",
          name: "stdout",
          command: "print_line",
          parameters: { data: "Starting batch operations..." }
        },
        {
          event: "resource",
          action: "command",
          name: "directory",
          command: "create",
          parameters: { path: "/tmp/batch_test" }
        },
        {
          event: "resource",
          action: "command",
          name: "file",
          command: "write",
          parameters: { path: "/tmp/batch_test/file1.txt", content: "Content 1" }
        },
        {
          event: "resource",
          action: "command",
          name: "file",
          command: "write",
          parameters: { path: "/tmp/batch_test/file2.txt", content: "Content 2" }
        },
        {
          event: "resource",
          action: "command",
          name: "stdout",
          command: "print_line",
          parameters: { data: "Batch operations completed!" }
        }
      ]
      
      commands.each do |command|
        # Execute command on client
        client_handler.handle(command)
        
        # Verify success
        response = test_adapter.response
        expect(response[:status]).to eq("success")
      end
    end
  end
end